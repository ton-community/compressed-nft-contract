#include "imports/stdlib.fc";
#include "imports/params.fc";
#include "imports/op-codes.fc";


global int storage::merkle_root;
global int storage::merkle_depth;
global cell storage::nft_item_code;
global slice storage::owner;
global cell storage::content;
global cell storage::royalty;
global cell storage::api_data;

const int error::not_owner = 100;
const int error::bad_proof = 101;
const int error::value_too_low = 102;
const int error::not_exotic = 103;
const int error::not_merkle_proof = 104;
const int error::wrong_hash = 105;
const int error::bad_update = 106;
const int error::invalid_zero_hashes = 107;
const int error::index_too_high = 108;

const int op::claim = "op::claim"c;
const int op::update = "op::update"c;

const int item_init_value = 30000000;
const int minimum_claim_value = 85000000;

const int cell_type::merkle_proof = 3;

(slice, int) begin_parse_exotic(cell x) asm "XCTOS";

cell zero_hashes_dict() asm " B{b5ee9c7241023b010004ab000201c71c010201200d020201200603020148050400412924e95a1b53a326c469c2934ef9d6d61276d45b26d175be95e0954d4ab45f8ca00041372c457f2b3c9896bb269fbf1f42e0966fb062dc8d85968ee9bc1d90ddbf5e5f600201200a0702012009080041141ae9ccd6f0c29613d6fd6a779909e34d406b6fa0d422c2b1117f91f57165dee00041117958c6c8e399b60950abd4e8c0012da388b971a3d5de2b9f512d58718a98e4e00201200c0b0041067999a06a7a50296ddd3845a4bb26ccafcfd50def3d413751a63cb54e0670cd2000413319f3ec0c7df03ce75a18abec64f8c965250a7e8a193af9a051f4ebc2f64cad60020120150e020120120f02012011100041247cc2769bb44e9a2d04e2bc8166036cd9ae1875f3bea688c175fe950d232c6da00041132b8507aa832e81f3af722b0786cd94fb5c3db44e0247a859f665ab754969b5a00201201413004118f939b4855228f5a4b965fdd0c446e9204c533179d034d198eb60fd1ef77118e000412725bce396275113929e99995a04bfe8ed9f9910430632b636c98b6fbdae50b0e00201201916020120181700410f2003946b7df8b0272279a045e9e916ae8fb0ca48f406684a3ba5611585756f20004137036394a4ad9fabf4098f700c1a2b26a2c6a4122225fbbd419a2d3d3f45206a200201201b1a004107c5c013022e6c980851802f902c24e93a3e7e6b0f93e8c21cd14ef202e770efe000413ee8a745d3d291599269536c1630915e4daddb3d5acd3a97e400e3b7303569a7600201202c1d020120251e020120221f020120212000410c9c73124c98bdef3465ecc20fd915aec03169e9796144f012a825c61bf7dac560004136b354771fae9458b017731834835d5d2017763a07d8bb3d79851dd790725689a0020120242300412bc9e953d5087aa25544752426d41f39547aa22c6073abd51261f8bb8d09c0616000411a7026bef2a1f6578b692fa5e728a570e195a0b7f562e9ef54471f102ccf0c80200201202926020120282700412b466b46039f7156683b6652fdadab78382b0d79bc1deb6cad3eb5a5350e5bb1a000412a0b55af8a33479ec565a21ba52c9c9139b3f6079b73a0e8de242fde239b9fab200201202b2a0041033ed2411b5fc91088caf7eb13da9d48842f0809bf1c37b83a7eff511ff19b0f200041163a81eada1caddedfb9cdb455e771080bb9e288b3efe5e8082050af0463d915a0020120342d020120312e020120302f00412dfbdcbddd8301f96afb72bc36dd2a57e1eb141b22eaf15e45d4d6040547c38660004107cc387c90de5176110fcc8a63a99629b3d93f0b138795b2ec3f4df9bf756be7a002012033320041139f226107c6bea682dc41b23360b2e736ae1f2ac9d33186ee539ca6c9a8c451a000413e6f4348078f15e0fd3977e7c5f5d61d417a0b0007960c5682eea515f6eaf01fe00201203835020120373600410526d4e74a28305ad88dc6f5bafb655c54075306c564211dadb5654e7b9c92a86000412b04ac54adb5437b7db87fc2373d926ddb3455784e7d91f44d0c5983c1cc87b5a00201203a3900413c92216fe16fce3d2afca7c3aca45d10e5e1d1903fe79dfd549b18600323b7c2a000410e1254b628016fc636df30b61c6fe19c7f8e8d19631954f5d218ce28106be18a205639ff04} B>boc PUSHREF ";

int zero_hash(int depth) {
    (slice data, int found) = zero_hashes_dict().udict_get?(8, depth);
    throw_unless(error::invalid_zero_hashes, found);

    return data.preload_uint(256);
}

() load_data() impure {
    slice ds = get_data().begin_parse();

    storage::merkle_root = ds~load_uint(256);
    storage::merkle_depth = ds~load_uint(8);
    storage::nft_item_code = ds~load_ref();
    storage::owner = ds~load_msg_addr();
    storage::content = ds~load_ref();
    storage::royalty = ds~load_ref();
    storage::api_data = ds~load_ref();

    ds.end_parse();
}

() save_data() impure {
    set_data(begin_cell()
        .store_uint(storage::merkle_root, 256)
        .store_uint(storage::merkle_depth, 8)
        .store_ref(storage::nft_item_code)
        .store_slice(storage::owner)
        .store_ref(storage::content)
        .store_ref(storage::royalty)
        .store_ref(storage::api_data)
        .end_cell());
}

(slice, cell) parse_nft_data(cell nft_data) {
    slice ds = nft_data.begin_parse();
    return (ds~load_msg_addr(), ds~load_ref());
}

cell calculate_nft_item_state_init(int item_index, cell nft_item_code) {
    cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell();
    return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell();
}

slice calculate_nft_item_address(cell state_init) {
    return begin_cell()
        .store_uint(4, 3)
        .store_int(workchain, 8)
        .store_uint(cell_hash(state_init), 256)
        .end_cell()
        .begin_parse();
}

() deploy_nft_item(int item_index, int amount, cell nft_message) impure {
    cell state_init = calculate_nft_item_state_init(item_index, storage::nft_item_code);
    slice nft_address = calculate_nft_item_address(state_init);
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(nft_address)
        .store_coins(amount)
        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
        .store_ref(state_init)
        .store_ref(nft_message);
    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

(cell, int) extract_merkle_proof(cell proof) impure {
    (slice s, int is_exotic) = proof.begin_parse_exotic();
    throw_unless(error::not_exotic, is_exotic);

    int ty = s~load_uint(8);
    throw_unless(error::not_merkle_proof, ty == cell_type::merkle_proof);

    return (s~load_ref(), s~load_uint(256));
}

cell check_merkle_proof(cell proof, int expected_hash) impure {
    (cell inner, int hash) = proof.extract_merkle_proof();
    throw_unless(error::wrong_hash, hash == expected_hash);

    return inner;
}

cell retrieve_child(cell c, int index, int depth) {
    depth -= 1;
    while (depth >= 0) {
        slice s = c.begin_parse();
        if ((index >> depth) & 1) {
            s~load_ref();
            c = s~load_ref();
        } else {
            c = s~load_ref();
        }
        depth -= 1;
    }
    return c;
}

() claim(int nft_index, cell proof) impure {
    throw_if(error::index_too_high, nft_index >= (1 << storage::merkle_depth));

    cell struct = proof.check_merkle_proof(storage::merkle_root);
    cell nft_data = struct.retrieve_child(nft_index, storage::merkle_depth);

    (slice owner, cell content) = nft_data.parse_nft_data();

    deploy_nft_item(nft_index, item_init_value, begin_cell().store_slice(owner).store_ref(content).end_cell());
}

() check_update(cell old, cell new, int depth) impure {
    if (old.cell_depth() == 0) {
        if (old.cell_hash() == new.cell_hash()) {
            return ();
        }

        (slice s, int is_exotic) = old.begin_parse_exotic();
        throw_unless(error::bad_update, is_exotic);

        int ty_lvl = s~load_uint(16);
        throw_unless(error::bad_update, ty_lvl == 0x0101);

        int old_hash = s~load_uint(256);
        throw_unless(error::bad_update, old_hash == zero_hash(depth));
    } else {
        slice s_old = old.begin_parse();
        slice s_new = new.begin_parse();
        check_update(s_old~load_ref(), s_new~load_ref(), depth - 1);
        check_update(s_old~load_ref(), s_new~load_ref(), depth - 1);
    }
}

() update(cell update) impure {
    slice s = update.begin_parse();
    cell old_merkle = s~load_ref();
    cell new_merkle = s~load_ref();

    cell old = old_merkle.check_merkle_proof(storage::merkle_root);
    (cell new, int new_hash) = new_merkle.extract_merkle_proof();

    check_update(old, new, storage::merkle_depth);

    storage::merkle_root = new_hash;

    save_data();
}

() send_royalty_params(slice to_address, int query_id, slice data) impure inline {
    var msg = begin_cell()
        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
        .store_slice(to_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::report_royalty_params(), 32)
        .store_uint(query_id, 64)
        .store_slice(data);
    send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == op::claim) {
        throw_unless(error::value_too_low, msg_value >= minimum_claim_value);

        claim(in_msg_body~load_uint(256), in_msg_body~load_ref());
        return ();
    }

    if (op == op::update) {
        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));
        update(in_msg_body~load_ref());

        var msg = begin_cell()
            .store_uint(0x18, 6) 
            .store_slice(sender_address)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::excesses(), 32)
            .store_uint(query_id, 64);
        send_raw_message(msg.end_cell(), 64);
        return ();
    }

    if (op == op::withdraw) {
        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));
        
        raw_reserve(50000000, 0);

        var msg = begin_cell()
            .store_uint(0x18, 6) 
            .store_slice(sender_address)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::excesses(), 32)
            .store_uint(query_id, 64);
        send_raw_message(msg.end_cell(), 128);
        return ();
    }

    if (op == op::get_royalty_params()) {
        send_royalty_params(sender_address, query_id, storage::royalty.begin_parse());
        return ();
    }

    throw(0xffff);
}

(int, cell, slice) get_collection_data() method_id {
    load_data();
    slice cs = storage::content.begin_parse();
    return (-1, cs~load_ref(), storage::owner);
}

slice get_nft_address_by_index(int index) method_id {
    load_data();
    cell state_init = calculate_nft_item_state_init(index, storage::nft_item_code);
    return calculate_nft_item_address(state_init);
}

(int, int, slice) royalty_params() method_id {
    load_data();
    slice rs = storage::royalty.begin_parse();
    return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());
}

cell get_nft_content(int index, cell individual_nft_content) method_id {
    load_data();
    slice cs = storage::content.begin_parse();
    cs~load_ref();
    slice common_content = cs~load_ref().begin_parse();
    return (begin_cell()
            .store_uint(1, 8) ;; offchain tag
            .store_slice(common_content)
            .store_ref(individual_nft_content)
            .end_cell());
}

int get_merkle_root() method_id {
    load_data();
    return storage::merkle_root;
}

(int, cell) get_nft_api_info() method_id {
    load_data();
    slice cs = storage::api_data.begin_parse();
    int version = cs~load_uint(8);
    cell link = cs~load_ref();
    return (version, link);
}
